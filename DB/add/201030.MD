


# java
```java
public static void main(String[] args) {
    double s = 0;
    for (int i=0; i<100; i++) {
        s += 0.01;
    }
    System.out.println(s);
}
```
### 123을 10진법으로 표현
```java
123 % 10 = 3
12 % 10 = 2
1 % 10 = 1

```

### 123을 2진법으로 표현
```java
123 % 2 : 61, 1
61 % 2 : 30, 1
30 % 2 : 15, 0
15 % 2 : 7, 1
7 % 2 : 3, 1
3 % 2 : 1, 1
1 % 2 : 0, 1
--------------
1111011
``` 

### 0.45 -> 10진수

```java

0.45 * 10 - 정수 : 4, 소수 : 0.5
0.5 * 10 - 정수 : 5, 소수 : 0
```

### 0.45 -> 2진수
```java
0.45 * 2 - 0.9(0)
0.9 * 2 - 1.8(1)
0.8 * 2 - 1.6(1)
0.6 * 2 - 1.2(1)
0.2 * 2 - 0.4(0)
0.4 * 2 - 0.8(0)
0.8 * 2 - 1.6(1)
...
------------------
0111001...
```

## 객체지향

객체 지향의 장점: 설계부터 구현까지 객체라는 하나의 일관된 관점으로 문제를 풀어나갈 수 있음

객체 지향 패러다임의 핵심

- 역할: 협력 안에서 수행하는 책임들이 모여서 이루는 기능
- 책임: 협력에 참여하기 위해 각자 수행하는 로직
- 협력: 기능 수행을 위해 객체 간 상호작용

자율적인 객체의 공동체 -> 의인화

### 협력

메세지 전송(message sending)
- 객체가 다른 객체에게 협력을 구하는 유일한 수단
- 메시지를 수신한(협력 요청) 객체는 메서드를 실행해 요청에 응답함

왜 함수가 아니라 메서드인가?
- 자기 자신의 방법으로 `책임`을 수행하는 것

객체를 `자율적`으로 만드는 가장 기본적인 방법
- 캡슐화  
-> 변경에 대한 파급효과를 제한하는 것

객체의 행동을 결정하는 것
- 객체가 참여하는 협력

> 상태는 객체가 협력하는 데 필요한 정보에 의해 결정되고  
> 협력 안에서 객체가 처리할 메세지로 결정됨  
> 협력은 객체 설계에 필요한 문맥을 제공  

### 책임

객체의 책임은
- 무엇을 알고 있는가
- 무엇을 할 수 있는가

하는 것
- 객체를 생성하거나 계산을 하는 등의 자율적으로 하는 것
- 다른 객체의 행동을 시작 시키는 것(메세지, 협력)
- 다른 객체의 활동을 제어하고 조절

아는 것
- 사적인 정보에 대해서 아는 것
- 관련된 객체에 대해서 아는 것
- 자신이 유도하거나 계산할 수 있는 것에 관해서 아는 것

책임 할당  
`정보 전문가 패턴`

### 메세지가 객체를 결정한다

- 책임을 할당하는데 필요한 메세지를 먼저 식별하고 메세지를 처리할 객체를 나중에 선택

1. 최소한의 인터페이스
2. 충분히 추상적인 인터페이스

### 행동이 상태를 결정한다

OOP의 가장 초보적인 실수
- 상태를 결정하고, 상태에 필요한 행동을 만듬
  - 내부 구현이 퍼블릭 인터페이스에 노출이 됨 -> 캡슐화 저해

### 역할

잘 이어붙이기? 이건 당연함.  
협력 관계를 잘 구성
-> policy(역할, 슬롯) 예제

<br>

## 상속

코드 재사용을 목적으로 사용하면 발생할 수 있는 문제 ???

1. 불필요한 인터페이스 상속
2. 메서드 오버라이딩  
--> 원래 노출된 의도랑 동작이 변경됨
3. 부모 클래스와 코드를 공유하기 때문에 변경에 의한 사이드이펙트가 자식에게 전파
4. 부모 클래스가 노출 -> 캡슐화 깨짐.


<br>
코드 재사용이 목적이라면 
    
  --> 상속보다는 합성을 사용하자.
- 합성관계 --> 동적으로 객체를 결정 할 수 있다. (실행시간)

그렇다면 상속이 필요한 곳은 ?  
타입이 계층적으로 표현될 때 >> 타입 계층 구조화
<br>

ex)  
메가커피의 상품
- 커피
- 스무디
- 케이크

## 클래스 선언
```java
접근지정자 class 클래스이름 {
    접근지정자 타입 변수이름;
    메소드()
}
```

#### 접근지정자 : 언어 레벨에서 캡슐화
- private : 객체 내부에서만 접근 가능
- protected : 패키지 내부에서만 접근 가능
- public : 모든 패키지 및 클래스에서 접근 가능


#### 한정자(modifier)  
- static : 클래스에 소속시킨다.
```java
ABC.method();
```

- final : 확장/변경 불가능
1. 클래스 : 이 클래스를 상속하지 말 것.
2. 변수 : 상수

- abstract : 추상 클래스 / 메서드

#### 생성 방법
```java
final Object obj = new Object;
//final : 변경가능성을 막으려고~~~
```

#### 메소드
- 이름
- 시그니처 : 반환형은 포함되지 않음.
    - 메소드 이름
    - 파리미터 목록 
- 바디

#### 가변인자
배열처럼 사용할 수 있으며 여러가지 값을 담을 수 있다.
```java
method(타입 ...파라미터);
```
